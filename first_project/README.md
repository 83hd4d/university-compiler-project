# پروژه اول

## FLEX

### نمونه کد

```c
/* Auxiliary declarations */
%{
    #include <that_library.h>

    int global_variable1;
    int global_variable2;

    int auxiliary_function1();
    int auxiliary_function2();    
    int auxiliary_function3();
%}

/* Regular definitions */
Number [0-9]
LETTER [a-zA-Z]

/* Rules */
%%
Rule1 {auxiliary_function1();}
Rule2 {auxiliary_function2();}
Rule3
Rule4   {auxiliary_function3();}
%%

/* Auxiliary functions */
int yywrap(){}
int main(){
    yylex();
    return 0;
}
int auxiliary_function1(){
    /*Does something*/
}
int auxiliary_function2(){
    /*Does something*/
}
int auxiliary_function3(){
    /*Does something*/
}

```

### Auxiliary declarations

در این قسمت از برنامه میتوان اعمال زیر را انجام داد:

- اضافه کردن کتابخانه های مورد نیاز
- تعربف کردن متغیر های سراسری
- اعلام کردن توابع کمکی

### Regular definitions

در این قسمت میتوان ثوابتی را تعریف کرد که در ادامه از آنها در قسمت قوانین استفاده شود. نحوه مقداردهی به این ثوابت از عبارات منظم پیروی می کند.

#### مثال

```c
NUMBER  [0-9]   /*مجموعه ارقام*/
LETTER  [a-zA-Z]    /*مجموعه حروف*/ 
WHITESPACE  [ \t\n] /*مجموعه کارکتر های نشان دهنده فضای خالی*/
IF  [Ii][Ff]    /*عبارت منظمی برای تشخیص یک توکن*/
ID  {LETTER}({LETTER}|{DIGIT})* /*عبارت منظمی برای تشخیص یک توکن*/

```

### Rules

در این قسمت عبارت منظم مورد نظر به ترتیب قرارداده می شوند. میتوان در برابر هر قانون مجموعه ای از دستورات را درون آکولاد قرار داد تا در زمان قبول شدن یک ورودی توسط آن قانون اجرا شوند.

### Auxiliary functions

در این قسمت توابع کمکی را تعریف می کنیم. در این قسمت تعریف کردن حداقل یک تابع `main` الزامی است.

### The yyvariables

#### yyin

این متغیر میتواند یک از دو مقدار زیر را داشته باشد:

1. اگر می خواهیم ورودی را از یک فایل بخوانیم این متغیر از نوع `FILE*` خواهد بود و به فایل ورودی ما اشاره خواهد کرد.
2. در غیر این صورت این متغیر برابر با `stdin` (ورودی کنسول) برابر خواهد بود.

#### yytext

این متغیر از نوع `char*` است و به `lexme` فعلی اشاره میکند. `lexme` دنباله ای از کارکتر ها در ورودی است که با یکی از قوانین موجود مطابقت دارد.

#### yyleng

این متغیر از نوع `int` است و مقدار آن برابر با طول `lexme` ای است که `yytext` به آن اشاره می کند.

### The yyfunctions

#### yylex()

این تابع یک مقدار از نوع `int` را بر می گرداند. FLEX به صورت خودکار این تابع را تعریف می کند ولی نیاز است که برنامه نویس آن را در قسمت `Auxiliary functions` فراخوانی کند. کد این تابع بر اساس قوانین تعریف شده در قسمت `Rules` توسط FLEX ایجاد می شود. زمانی که این تابع فراخوانی می شود، ورودی که `yyin` به آن اشاره میکند را می خواند. زمانی که ورودی یا بخشی از آن با یکی از قوانین تعریف شده تطابق می یابد، `yylex()` دستورات مربوط به آن قانون را اجرا می کند. این روند تا جایی ادامه پیدا می کند که به انتهای فایل برسد یا برنامه نویس کدی  نوشته باشد که آن را مجبور به `return` یک مقدار کند. اگر ورودی از کنسول خوانده می شود، می توان این روند را با ارسال `ctrl+d` نیز پایان داد.

این تابع برای رفع ابهام از دو قانون زیر استفاده می کند:

1. اولین تطابق انتخاب می شود.
2. طولانی ترین تطابق ترجیح داده می شود.

#### yywrap()

این تابع با مقدار بازگشتی از نوع `int` توسط FLEX اعلام می شود، ولی برای آن بدنه ای تعریف نمی شود. به همین دلیل برنامه نویس یا باید این تابع را در قسمت `Auxiliary functions` تعریف کند، یا عدم وجود آن را در قسمت `Auxiliary declarations` با دستور `%option noyywrap` اعلام کند. زمانی که تابع `yylex()` به انتهای فایل یا ورود می رسد، این تابع را فراخوانی میکند. اگر این تابع مقدار غیر ۰ را برگرداند، برنامه به پایان می رسد. اگر بخواهیم که `yylex()` چند فایل را بخواند، باید در این تابع `yyin` را روی فایل بعدی قرار داد و مقدار ۰ را برگرداند.

## شرح پروژه

### صورت مسئله

برای توکن زیر یک تحلیلگر لغوی به زبان LEX ایجاد کنید.

تمام رشته های تولید شده از `{a,b,c}` که با `a` شروع شده و با `bb` خاتمه یابند.

### پاسخ

```c
/* Auxiliary declarations */
%{
    void print_instruction();
    void matched_rule();
    void other();    
%}

/* Regular definitions */
Alphabet [a,b,c]

/* Rules */
%%
^a{Alphabet}*bb$ {matched_rule();}
[ \t\n]+ /* eat up whitespace */
^.*$ {other();}
%%

/* Auxiliary functions */
int yywrap(){
    printf("\nGoodbye!!!\n");
}
int main(){
    print_instruction();
    yylex();
    return 0;
}
void print_instruction(){
    printf("Type an string and press ENTER: ");
}
void matched_rule(){
    printf("'%s' matched the RegEx rule.\n", yytext);
    print_instruction();
}
void other(){
    printf("'%s' didn't match the RegEx rule.\n", yytext);
    print_instruction();
}
```

1. ابتدا ۳ تابع کمکی را اعلام می کنیم که در ادامه برنامه از آنها استفاده خواهیم کرد.
2. سپس یک ثابت به نام `Alphabet` تعریف میکنیم که برابر با مجموعه الفبای ماست.
3. در این قسمت قوانین را تعریف می کنیم. قانون اول هنگام شناسایی، توکن مورد نظر ما تابع `matched_rule` را اجرا میکند. قانون دوم برای نادیده گرفتن `whitespace` های احتمالی موجود در `stdin` نوشته شده و در نتیجه هنگام شناسایی، هیچ کدی اجرا نمیکند. در نهایت قانون سوم برای شناسایی رشته هایی که برابر با توکن ما نیستند نوشته شده و تابع `other` را اجرا می کند.
4. در نهایت توابع کمکی را تعریف می کنیم.

### کامپایل

![commands](./commands.png)

کد های ذکر شده در فایلی به نام `first_project.l` قرار دارند.

ابتدا با دستور `flex first_project.l` فایل `lex` را به زبان `c` تبدیل می کنیم. نام فایل خروجی به صورت پیش فرض برابر با `lex.yy.c` است.

سپس با استفاده از دستور `gcc lex.yy.c` فایل را کامپایل می کنیم. نام پیش فرض فایل خروجی برابر با `a.out` است.

### نمونه ورودی و خروجی

![example](./example.png)